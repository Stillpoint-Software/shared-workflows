name: Template Update

on:
  workflow_call:
    inputs:
      template_repo:
        description: "URL of the Cookiecutter template repo"
        required: true
        type: string
      repo_branch:
        description: "Branch of the project repo to update"
        required: true
        type: string
      update_workflows:
        description: "Include .github/workflows updates from template? (true/false)"
        required: false
        type: boolean
        default: false
     secrets:
      TEMPLATE_UPDATE_TOKEN:
        required: false

permissions:
  contents: write
  pull-requests: write

jobs:
  check-update:
    runs-on: ubuntu-latest
    outputs:
      sha_changed: ${{ steps.compare.outputs.sha_changed }}
      old_sha: ${{ steps.old_sha.outputs.sha }}
      new_sha: ${{ steps.new_sha.outputs.sha }}

    steps:
      - name: Checkout project repo (cookiecutter metadata only)
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository }}
          ref: ${{ inputs.repo_branch }}
          sparse-checkout: .cookiecutter.json
          sparse-checkout-cone-mode: false

      - name: Read old template SHA
        id: old_sha
        shell: bash
        run: |
          SHA=$(jq -r '.cookiecutter.template_sha // empty' .cookiecutter.json)
          if [ -z "$SHA" ]; then
            echo "::error ::.cookiecutter.json is missing cookiecutter.template_sha"
            exit 1
          fi
          echo "sha=$SHA" >> "$GITHUB_OUTPUT"

      - name: Fetch new template SHA
        id: new_sha
        shell: bash
        run: |
          echo "sha=$(git ls-remote '${{ inputs.template_repo }}' HEAD | cut -f1)" >> "$GITHUB_OUTPUT"

      - name: Compare SHAs
        id: compare
        shell: bash
        run: |
          if [ "${{ steps.old_sha.outputs.sha }}" = "${{ steps.new_sha.outputs.sha }}" ]; then
            echo "âœ‚ï¸ SHA unchanged; nothing to update."
            echo "sha_changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "sha_changed=true" >> "$GITHUB_OUTPUT"
          fi

  template-update:
    needs: check-update
    if: needs.check-update.outputs.sha_changed == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Resolve update_workflows flag
        id: wf
        shell: bash
        run: |
          if [ "${{ inputs.update_workflows }}" = "true" ]; then
            echo "enabled=true" >> "$GITHUB_OUTPUT"
          else
            echo "enabled=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Enforce workflow token if updating workflows
        shell: bash
        run: |
          set -euo pipefail
          if [ "${{ steps.wf.outputs.enabled }}" = "true" ] && [ -z "${{ secrets.TEMPLATE_UPDATE_TOKEN }}" ]; then
            echo "::error ::update_workflows=true requires secrets.TEMPLATE_UPDATE_TOKEN (PAT with repo+workflow)."
            exit 1
          fi

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "10.0.x"

      - name: Checkout project repo
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository }}
          ref: ${{ inputs.repo_branch }}
          fetch-depth: 0
          submodules: false
          # If updating workflows, we must use a PAT that can update workflow files.
          # Otherwise, default GITHUB_TOKEN is fine.
          token: ${{ steps.wf.outputs.enabled == 'true' && secrets.TEMPLATE_UPDATE_TOKEN || github.token }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.x"

      - name: Install dependencies
        shell: bash
        run: |
          pip install cookiecutter

      - name: Prepare branch name
        id: branch
        shell: bash
        run: |
          NEW_SHA="${{ needs.check-update.outputs.new_sha }}"
          BRANCH="template-update-${NEW_SHA}"
          echo "name=$BRANCH" >> "$GITHUB_OUTPUT"

      - name: Check if a template update PR is already open
        shell: bash
        env:
          GH_TOKEN: ${{ steps.wf.outputs.enabled == 'true' && secrets.TEMPLATE_UPDATE_TOKEN || github.token }}
        run: |
          set -euo pipefail
          BRANCH="${{ steps.branch.outputs.name }}"
          BASE="${{ inputs.repo_branch }}"
          URL=$(gh pr list --state open --head "$BRANCH" --base "$BASE" --json url --jq '.[0].url')

          if [ -n "$URL" ] && [ "$URL" != "null" ]; then
            echo "::error ::An open PR already exists for branch '$BRANCH': $URL"
            exit 1
          fi

      - name: Check if update branch already exists
        shell: bash
        run: |
          BRANCH="${{ steps.branch.outputs.name }}"
          if git ls-remote --exit-code --heads origin "$BRANCH" >/dev/null 2>&1; then
            echo "::error ::Branch '$BRANCH' already exists (possibly from an existing PR or a previous run)."
            exit 1
          fi

      - name: Clone template repo
        shell: bash
        run: |
          set -euo pipefail
          rm -rf /tmp/template-source || true
          git clone '${{ inputs.template_repo }}' /tmp/template-source

      - name: Render template at old SHA
        shell: bash
        run: |
          set -euo pipefail
          cd /tmp/template-source
          git checkout "${{ needs.check-update.outputs.old_sha }}"

          rm -rf ~/.cookiecutters/* || true
          rm -rf /tmp/rendered-old || true

          cookiecutter /tmp/template-source \
            --replay-file "$GITHUB_WORKSPACE/.cookiecutter.json" \
            --overwrite-if-exists \
            --output-dir /tmp/rendered-old

      - name: Capture rendered OLD directory name
        id: rendered_old
        shell: bash
        run: |
          DIR=$(ls /tmp/rendered-old | head -n 1)
          if [ -z "$DIR" ]; then
            echo "::error ::No rendered output found in /tmp/rendered-old"
            exit 1
          fi
          echo "name=$DIR" >> "$GITHUB_OUTPUT"

      - name: Render template at new SHA
        shell: bash
        run: |
          set -euo pipefail
          cd /tmp/template-source
          git checkout "${{ needs.check-update.outputs.new_sha }}"

          rm -rf ~/.cookiecutters/* || true
          rm -rf /tmp/rendered-new || true

          cookiecutter /tmp/template-source \
            --replay-file "$GITHUB_WORKSPACE/.cookiecutter.json" \
            --overwrite-if-exists \
            --output-dir /tmp/rendered-new

      - name: Capture rendered NEW directory name
        id: rendered_new
        shell: bash
        run: |
          DIR=$(ls /tmp/rendered-new | head -n 1)
          if [ -z "$DIR" ]; then
            echo "::error ::No rendered output found in /tmp/rendered-new"
            exit 1
          fi
          echo "name=$DIR" >> "$GITHUB_OUTPUT"

      - name: Create update branch from repo branch
        shell: bash
        run: |
          git checkout -b "${{ steps.branch.outputs.name }}"

      - name: Sync rendered NEW project into repo (non-destructive)
        shell: bash
        run: |
          set -euo pipefail
          SRC="/tmp/rendered-new/${{ steps.rendered_new.outputs.name }}/"

          if [ "${{ steps.wf.outputs.enabled }}" = "true" ]; then
            echo "Including workflow updates from template"
            rsync -a --exclude ".git/" "$SRC" "$GITHUB_WORKSPACE"
          else
            echo "Excluding workflow updates from template"
            rsync -a --exclude ".git/" --exclude ".github/workflows/" "$SRC" "$GITHUB_WORKSPACE"
          fi

      - name: Delete files removed from template (old â†’ new)
        shell: bash
        run: |
          set -euo pipefail

          OLD_DIR="/tmp/rendered-old/${{ steps.rendered_old.outputs.name }}"
          NEW_DIR="/tmp/rendered-new/${{ steps.rendered_new.outputs.name }}"

          echo "ðŸ” Detecting files removed from template..."

          if [ ! -d "$OLD_DIR" ] || [ ! -d "$NEW_DIR" ]; then
            echo "::error ::Rendered directories not found. OLD_DIR=$OLD_DIR NEW_DIR=$NEW_DIR"
            exit 1
          fi

          (cd "$OLD_DIR" && find . -type f -print0) | while IFS= read -r -d '' file; do
            rel_path="${file#./}"

            # If not updating workflows, do not delete workflow files
            if [ "${{ steps.wf.outputs.enabled }}" != "true" ] && [[ "$rel_path" == .github/workflows/* ]]; then
              continue
            fi

            if [ ! -f "$NEW_DIR/$rel_path" ] && [ -f "$GITHUB_WORKSPACE/$rel_path" ]; then
              echo "ðŸ—‘ï¸ Deleting: $rel_path"
              rm -f "$GITHUB_WORKSPACE/$rel_path"
            fi
          done

          cd "$GITHUB_WORKSPACE"
          find . -type d -empty -not -path './.git/*' -delete 2>/dev/null || true

      - name: Update .cookiecutter.json template_sha + prune deprecated vars
        shell: bash
        run: |
          set -euo pipefail
          NEW_SHA="${{ needs.check-update.outputs.new_sha }}"

          jq ".cookiecutter.template_sha = \"${NEW_SHA}\"" \
            .cookiecutter.json > tmp.json && mv tmp.json .cookiecutter.json

          if [ -f "/tmp/template-source/hooks/prune_cookiecutter_json.py" ] && [ -f "/tmp/template-source/hooks/deprecated.json" ]; then
            python /tmp/template-source/hooks/prune_cookiecutter_json.py \
              --cookie .cookiecutter.json \
              --deprecations /tmp/template-source/hooks/deprecated.json
          else
            echo "â„¹ï¸ prune_cookiecutter_json.py or deprecated.json not found; skipping prune."
          fi

      - name: Format C# (dotnet format - all src projects)
        shell: bash
        run: |
          set -euo pipefail

          if [ ! -d "src" ]; then
            echo "â„¹ï¸ No src directory; skipping dotnet format."
            exit 0
          fi

          shopt -s nullglob
          CSPROJS=(src/*.csproj)
          shopt -u nullglob

          if [ "${#CSPROJS[@]}" -eq 0 ]; then
            echo "â„¹ï¸ No src/*.csproj found; skipping dotnet format."
            exit 0
          fi

          for p in "${CSPROJS[@]}"; do
            echo "ðŸ§¼ Restoring and formatting $p"
            dotnet restore "$p"
            dotnet format whitespace "$p" --no-restore
            dotnet format style "$p" --no-restore
          done

      - name: Remove extra blank lines (src - .cs and .csproj)
        shell: pwsh
        run: |
          if (-not (Test-Path "src")) {
            Write-Host "â„¹ï¸ No src directory; skipping blank-line cleanup."
            exit 0
          }

          $files = @()
          $files += Get-ChildItem -Path "src" -Recurse -Filter "*.cs" -File
          $files += Get-ChildItem -Path "src" -Recurse -Filter "*.csproj" -File

          if (-not $files -or $files.Count -eq 0) {
            Write-Host "â„¹ï¸ No .cs or .csproj files under src/; skipping blank-line cleanup."
            exit 0
          }

          foreach ($f in $files) {
            $text = Get-Content -Path $f.FullName -Raw
            $normalized = $text -replace "`r`n", "`n"
            $collapsed = [regex]::Replace($normalized, "`n{3,}", "`n`n")
            if ($collapsed -ne $normalized) {
              Set-Content -Path $f.FullName -Value $collapsed -NoNewline
            }
          }

      - name: Commit changes (if any)
        id: commit
        shell: bash
        run: |
          set -euo pipefail
          OLD_SHA="${{ needs.check-update.outputs.old_sha }}"
          NEW_SHA="${{ needs.check-update.outputs.new_sha }}"

          git config user.name "GitHub Actions Bot"
          git config user.email "actions@github.com"

          git add -A

          if git diff --cached --quiet; then
            echo "No changes after render/sync; skipping PR."
            echo "has_changes=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          git commit -m "chore: update from template ${OLD_SHA} â†’ ${NEW_SHA}"
          echo "has_changes=true" >> "$GITHUB_OUTPUT"

      - name: Push branch
        if: steps.commit.outputs.has_changes == 'true'
        shell: bash
        run: |
          set -euo pipefail
          git push -u origin "${{ steps.branch.outputs.name }}"

      - name: Create pull request (no merge)
        if: steps.commit.outputs.has_changes == 'true'
        shell: bash
        env:
          GH_TOKEN: ${{ steps.wf.outputs.enabled == 'true' && secrets.TEMPLATE_UPDATE_TOKEN || github.token }}
        run: |
          set -euo pipefail
          OLD_SHA="${{ needs.check-update.outputs.old_sha }}"
          NEW_SHA="${{ needs.check-update.outputs.new_sha }}"
          BRANCH="${{ steps.branch.outputs.name }}"

          BODY="Updates from template SHA \`${OLD_SHA}\` â†’ \`${NEW_SHA}\`"

          gh pr create \
            --title "chore: update from template ${OLD_SHA} â†’ ${NEW_SHA}" \
            --body "$BODY" \
            --base '${{ inputs.repo_branch }}' \
            --head "$BRANCH"
